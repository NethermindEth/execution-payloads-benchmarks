import http from 'k6/http';
import { group, check } from 'k6';
import { SharedArray } from 'k6/data';
import exec from 'k6/execution';
import encoding from 'k6/encoding';
import crypto from 'k6/crypto';

// --- Env / config ---
const payloadsFilePath = __ENV.EXPB_PAYLOADS_FILE_PATH;
const fcusFilePath     = __ENV.EXPB_FCUS_FILE_PATH;
const startLine        = parseInt(__ENV.EXPB_PAYLOADS_START || '1', 10);
const ABORT_ON_EOF     = (__ENV.EXPB_ABORT_ON_EOF || '0') === '1';
const ADD_CORRELATION_HEADER = (__ENV.EXPB_ADD_CID || '1') === '1';
const engineEndpoint   = __ENV.EXPB_ENGINE_ENDPOINT;

// Load k6 options JSON
const config = JSON.parse(open(__ENV.EXPB_CONFIG_FILE_PATH));
export const options = config["options"];

// --- Data ---
const payloadLines = new SharedArray('expb_payload_lines', () =>
  open(payloadsFilePath).trim().split(/\r?\n/)
);
const fcuLines = new SharedArray('expb_fcu_lines', () =>
  open(fcusFilePath).trim().split(/\r?\n/)
);

const startIdx0  = Math.max(0, startLine - 1);
const totalPairs = Math.max(0, Math.min(payloadLines.length, fcuLines.length) - startIdx0);

// --- Helpers ---
function safeGetLine(arr, idx) {
  const v = (idx >= 0 && idx < arr.length) ? arr[idx] : '';
  return typeof v === 'string' ? v.replace(/^\uFEFF/, '').trim() : '';
}

// Tiny extractor to avoid full JSON.parse() just to tag the method
function extractMethodFast(raw) {
  const head = String(raw).slice(0, 256);
  const m = /"method"\s*:\s*"([^"]+)"/.exec(head);
  return m ? m[1] : undefined;
}

function hex2ArrayBuffer(hex) {
  const buf = new ArrayBuffer(hex.length / 2);
  const view = new Uint8Array(buf);
  for (let i = 0; i < hex.length; i += 2) view[i / 2] = parseInt(hex.slice(i, i + 2), 16);
  return buf;
}
const jwtsecretBytes = hex2ArrayBuffer(open(__ENV.EXPB_JWTSECRET_FILE_PATH).trim());

// Per-VU JWT cache (refresh ~once/minute)
let jwtCache = { token: '', exp: 0 };
function getJwtToken() {
  const now = Math.floor(Date.now() / 1000);
  if (jwtCache.token && now < (jwtCache.exp - 2)) return jwtCache.token;

  const header  = encoding.b64encode(JSON.stringify({ typ: 'JWT', alg: 'HS256' }), 'rawurl');
  const iat = now, exp = iat + 60;
  const payload = encoding.b64encode(JSON.stringify({ iat, exp }), 'rawurl');
  const h = crypto.createHMAC('sha256', jwtsecretBytes);
  h.update(header + '.' + payload);
  const sig = h.digest('base64rawurl');
  jwtCache = { token: `${header}.${payload}.${sig}`, exp };
  return jwtCache.token;
}

function cid() {
  return `${__ENV.testid || 'expb'}-vu${exec.vu.idInTest}-it${exec.scenario.iterationInTest}`;
}

export function setup() {
  // nothing; data preloaded
}

export default function () {
  const idx = startIdx0 + exec.scenario.iterationInTest;

  // Out of data? graceful (default) or abort if explicitly requested
  if (idx >= startIdx0 + totalPairs) {
    if (ABORT_ON_EOF) exec.test.abort('No more payloads or fcus found');
    return;
  }

  const payloadRaw = safeGetLine(payloadLines, idx);
  const fcuRaw     = safeGetLine(fcuLines, idx);

  if (!payloadRaw || !fcuRaw) {
    if (ABORT_ON_EOF) exec.test.abort('Dataset contains empty lines or ended prematurely');
    return;
  }

  const tok = getJwtToken();

  // --- engine_newPayload ---
  group('engine_newPayload', function () {
    const tags = { jrpc_method: extractMethodFast(payloadRaw) || 'engine_newPayload', kind: 'newPayload' };
    const headers = { Authorization: 'Bearer ' + tok, 'Content-Type': 'application/json' };
    if (ADD_CORRELATION_HEADER) headers['X-Expb-Cid'] = cid();

    const r = http.post(engineEndpoint, payloadRaw, { headers, tags });
    check(r, { 'status_200': (x) => x.status === 200 }, tags);
  });

  // --- engine_forkchoiceUpdated ---
  group('engine_forkchoiceUpdated', function () {
    const tags = { jrpc_method: extractMethodFast(fcuRaw) || 'engine_forkchoiceUpdated', kind: 'forkchoiceUpdated' };
    const headers = { Authorization: 'Bearer ' + tok, 'Content-Type': 'application/json' };
    if (ADD_CORRELATION_HEADER) headers['X-Expb-Cid'] = cid();

    const r = http.post(engineEndpoint, fcuRaw, { headers, tags });
    check(r, { 'status_200': (x) => x.status === 200 }, tags);
  });
}
