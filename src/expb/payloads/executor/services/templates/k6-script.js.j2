import http from 'k6/http';
import { group, check, sleep } from 'k6';
import { SharedArray } from 'k6/data';
import exec from 'k6/execution';
import encoding from 'k6/encoding';
import crypto from 'k6/crypto';
import { Gauge } from 'k6/metrics';

// --- Env / config ---
const payloadsFilePath = __ENV.EXPB_PAYLOADS_FILE_PATH;
const fcusFilePath = __ENV.EXPB_FCUS_FILE_PATH;
const payloadsSkip = parseInt(__ENV.EXPB_PAYLOADS_SKIP || '0', 10);
const payloadsWarmup = parseInt(__ENV.EXPB_PAYLOADS_WARMUP || '0', 10);
const payloadsDelay = parseFloat(__ENV.EXPB_PAYLOADS_DELAY || '0');
const payloadsWarmupDelay = parseFloat(__ENV.EXPB_PAYLOADS_WARMUP_DELAY || '0');
const warmupWait = parseInt(__ENV.EXPB_WARMUP_WAIT || '0', 10);
const abortOnEOF = (__ENV.EXPB_ABORT_ON_EOF || '0') === '1';
const addCorrelationHeader = (__ENV.EXPB_ADD_CID || '1') === '1';
const engineEndpoint = __ENV.EXPB_ENGINE_ENDPOINT;
const perPayloadMetrics = (__ENV.EXPB_PER_PAYLOAD_METRICS || '0') === '1';
const discardResponses = (__ENV.EXPB_DISCARD_RESPONSES || '1') === '1';
const enableLogging = (__ENV.EXPB_ENABLE_LOGGING || '0') === '1';
const perPayloadMetricsLogs = (__ENV.EXPB_PER_PAYLOAD_METRICS_LOGS || '0') === '1';

// Load k6 options JSON
const config = JSON.parse(open(__ENV.EXPB_CONFIG_FILE_PATH));
export const options = config["options"];

// --- Metrics ---
const slowestPayloads = new Gauge('expb_slowest_payloads');
const slowestProcessing = new Gauge('expb_slowest_processing');

// --- Data ---
// Pre-process payloads: normalize once during load, extract metadata
const payloadData = new SharedArray('expb_payload_data', () => {
  const lines = open(payloadsFilePath).trim().split(/\r?\n/);
  const processed = [];
  // Pre-compile regex for better performance
  const methodRegex = /"method"\s*:\s*"([^"]+)"/;
  const idRegex = /"id"\s*:\s*(\d+)/;
  const gasUsedRegex = /"gasUsed"\s*:\s*"([^"]+)"/;

  for (let i = 0; i < lines.length; i++) {
    let line = lines[i];
    // Normalize once: remove BOM and trim
    if (typeof line === 'string') {
      line = line.replace(/^\uFEFF/, '').trim();
    } else {
      line = '';
    }

    // Pre-extract metadata to avoid regex on every request
    const head = line.slice(0, 256);
    const methodMatch = methodRegex.exec(head);
    const idMatch = idRegex.exec(head);

    // Extract gasUsed (always extract, use conditionally later)
    const largerHead = line.slice(0, 2048);
    const gasMatch = gasUsedRegex.exec(largerHead);
    const gasUsed = gasMatch ? parseInt(gasMatch[1], 16) : undefined;

    processed.push({
      raw: line,
      method: methodMatch ? methodMatch[1] : undefined,
      jrpcId: idMatch ? parseInt(idMatch[1], 10) : undefined,
      gasUsed: gasUsed,
    });
  }
  return processed;
});

const fcuData = new SharedArray('expb_fcu_data', () => {
  const lines = open(fcusFilePath).trim().split(/\r?\n/);
  const processed = [];
  const methodRegex = /"method"\s*:\s*"([^"]+)"/;

  for (let i = 0; i < lines.length; i++) {
    let line = lines[i];
    if (typeof line === 'string') {
      line = line.replace(/^\uFEFF/, '').trim();
    } else {
      line = '';
    }

    const head = line.slice(0, 256);
    const methodMatch = methodRegex.exec(head);

    processed.push({
      raw: line,
      method: methodMatch ? methodMatch[1] : undefined,
    });
  }
  return processed;
});

const warmupIdx0 = Math.max(0, payloadsSkip);
const startIdx0 = warmupIdx0 + Math.max(0, payloadsWarmup);
const totalPairs = Math.max(0, Math.min(payloadData.length, fcuData.length) - startIdx0);

// --- Helpers ---
function safeGetPayload(idx) {
  return (idx >= 0 && idx < payloadData.length) ? payloadData[idx] : null;
}

function safeGetFcu(idx) {
  return (idx >= 0 && idx < fcuData.length) ? fcuData[idx] : null;
}

function hex2ArrayBuffer(hex) {
  const buf = new ArrayBuffer(hex.length / 2);
  const view = new Uint8Array(buf);
  for (let i = 0; i < hex.length; i += 2) view[i / 2] = parseInt(hex.slice(i, i + 2), 16);
  return buf;
}
const jwtsecretBytes = hex2ArrayBuffer(open(__ENV.EXPB_JWTSECRET_FILE_PATH).trim());

// Per-VU JWT cache (refresh ~once/minute)
// Pre-compute static JWT parts to avoid repeated JSON.stringify
const jwtHeaderB64 = encoding.b64encode(JSON.stringify({ typ: 'JWT', alg: 'HS256' }), 'rawurl');
let jwtCache = { token: '', exp: 0 };
function getJwtToken() {
  const now = Math.floor(Date.now() / 1000);
  if (jwtCache.token && now < (jwtCache.exp - 2)) return jwtCache.token;

  const iat = now, exp = iat + 60;
  const payload = encoding.b64encode(JSON.stringify({ iat, exp }), 'rawurl');
  const h = crypto.createHMAC('sha256', jwtsecretBytes);
  h.update(jwtHeaderB64 + '.' + payload);
  const sig = h.digest('base64rawurl');
  jwtCache = { token: `${jwtHeaderB64}.${payload}.${sig}`, exp };
  return jwtCache.token;
}

function cid() {
  return `${__ENV.testid || 'expb'}-vu${exec.vu.idInTest}-it${exec.scenario.iterationInTest}`;
}



function logPost(kind, idx, warmup, correlationId = '') {
  if (!enableLogging) return;
  const ts = new Date().toISOString();
  const warmupTag = warmup ? ' warmup=1' : '';
  const cidTag = correlationId ? ` cid=${correlationId}` : '';
  console.log(`[${ts}] POST ${kind} idx=${idx}${warmupTag}${cidTag}`);
}

let perPayloadMetricsTableHeaderPrinted = false;

function formatTableCell(value, width, alignRight = false) {
  const raw = value === undefined || value === null ? 'n/a' : String(value);
  if (raw.length >= width) return raw.slice(0, width);
  const pad = ' '.repeat(width - raw.length);
  return alignRight ? `${pad}${raw}` : `${raw}${pad}`;
}

function logPerPayloadMetricsRow(idx, payload, processingMs) {
  if (!enableLogging || !perPayloadMetricsLogs) return;

  const ts = new Date().toISOString();
  const separator = '+---------+------------+-----------------+';
  if (!perPayloadMetricsTableHeaderPrinted) {
    console.log(`[${ts}] ${separator}`);
    console.log(
      `[${ts}] | ${formatTableCell('payload', 7)} | ${formatTableCell('gas_used', 10)} | ${formatTableCell('processing_ms', 15)} |`
    );
    console.log(`[${ts}] ${separator}`);
    perPayloadMetricsTableHeaderPrinted = true;
  }

  const gasUsed = payload.gasUsed !== undefined ? payload.gasUsed : 'n/a';
  const processing = Number.isFinite(processingMs) ? processingMs.toFixed(2) : 'n/a';
  console.log(
    `[${ts}] | ${formatTableCell(idx, 7, true)} | ${formatTableCell(gasUsed, 10, true)} | ${formatTableCell(processing, 15, true)} |`
  );
}

function processPayload(idx, base_tags = {}, warmup = false) {
  // Out of data? graceful (default) or abort if explicitly requested
  if (idx >= startIdx0 + totalPairs) {
    if (abortOnEOF) exec.test.abort('No more payloads or fcus found');
    return;
  }

  const payload = safeGetPayload(idx);
  const fcu = safeGetFcu(idx);

  if (!payload || !fcu || !payload.raw || !fcu.raw) {
    if (abortOnEOF) exec.test.abort('Dataset contains empty lines or ended prematurely');
    return;
  }

  // Track start time to calculate elapsed time
  const startTime = Date.now();

  const correlationId = (!warmup && addCorrelationHeader) ? cid() : '';

  // --- engine_newPayload ---
  group('engine_newPayload', function () {
    // Generate fresh JWT token just before the request
    const jwtToken = getJwtToken();
    const headers = {
      'Authorization': 'Bearer ' + jwtToken,
      'Content-Type': 'application/json',
    };
    if (correlationId) {
      headers['X-Expb-Cid'] = correlationId;
    }

    const tags = {
      jrpc_method: payload.method || 'engine_newPayload',
      kind: 'newPayload',
      ...base_tags
    };

    logPost('engine_newPayload', idx, warmup, correlationId);
    const r = http.post(engineEndpoint, payload.raw, {
      headers: headers,
      tags: tags,
      responseType: discardResponses ? 'none' : 'text',
    });
    check(r, { 'status_200': (x) => x.status === 200 }, tags);

    if (!warmup) {
      logPerPayloadMetricsRow(idx, payload, r.timings.waiting);
    }

    if (!warmup && perPayloadMetrics) {
      const perPayloadMetricsTags = { ...tags };
      if (payload.jrpcId !== undefined) {
        perPayloadMetricsTags.jrpc_id = payload.jrpcId;
      }
      if (payload.gasUsed !== undefined) {
        perPayloadMetricsTags.gas_used = payload.gasUsed;
      }
      slowestPayloads.add(r.timings.duration, perPayloadMetricsTags);
      slowestProcessing.add(r.timings.waiting, perPayloadMetricsTags);
    }
  });

  // --- engine_forkchoiceUpdated ---
  group('engine_forkchoiceUpdated', function () {
    // Generate fresh JWT token just before the request
    const jwtToken = getJwtToken();
    const headers = {
      'Authorization': 'Bearer ' + jwtToken,
      'Content-Type': 'application/json',
    };
    if (correlationId) {
      headers['X-Expb-Cid'] = correlationId;
    }

    const tags = {
      jrpc_method: fcu.method || 'engine_forkchoiceUpdated',
      kind: 'forkchoiceUpdated',
      ...base_tags
    };

    logPost('engine_forkchoiceUpdated', idx, warmup, correlationId);
    const r = http.post(engineEndpoint, fcu.raw, {
      headers: headers,
      tags: tags,
      responseType: discardResponses ? 'none' : 'text',
    });
    check(r, { 'status_200': (x) => x.status === 200 }, tags);
  });

  // delay between payloads - wait only the difference between configured delay and elapsed time
  const delay = warmup ? payloadsWarmupDelay : payloadsDelay;
  if (delay > 0) {
    const elapsedTime = (Date.now() - startTime) / 1000; // Convert to seconds
    const remainingDelay = delay - elapsedTime;
    if (remainingDelay > 0) {
      sleep(remainingDelay);
    }
  }
}

export function setup() {
  // execute warmup payloads
  for (let idx = warmupIdx0; idx < startIdx0; idx++) {
    processPayload(idx, {}, true);
  }
}

export default function () {
  const idx = startIdx0 + exec.scenario.iterationInTest;
  if (exec.scenario.iterationInTest === 0 && warmupWait > 0) {
    sleep(warmupWait);
  }

  processPayload(idx, {}, false);
}
