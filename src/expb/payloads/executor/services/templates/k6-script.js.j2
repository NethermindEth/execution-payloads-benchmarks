import http from 'k6/http';
import { group, check } from 'k6';
import { SharedArray } from 'k6/data';
import exec from 'k6/execution';
import encoding from 'k6/encoding';
import crypto from 'k6/crypto';
import { Gauge } from 'k6/metrics';

// --- Env / config ---
const payloadsFilePath = __ENV.EXPB_PAYLOADS_FILE_PATH;
const fcusFilePath = __ENV.EXPB_FCUS_FILE_PATH;
const payloadsSkip = parseInt(__ENV.EXPB_PAYLOADS_SKIP || '0', 10);
const payloadsWarmup = parseInt(__ENV.EXPB_PAYLOADS_WARMUP || '0', 10);
const ABORT_ON_EOF = (__ENV.EXPB_ABORT_ON_EOF || '0') === '1';
const ADD_CORRELATION_HEADER = (__ENV.EXPB_ADD_CID || '1') === '1';
const engineEndpoint = __ENV.EXPB_ENGINE_ENDPOINT;
const PER_PAYLOAD_METRICS = (__ENV.EXPB_PER_PAYLOAD_METRICS || '0') === '1';

// Load k6 options JSON
const config = JSON.parse(open(__ENV.EXPB_CONFIG_FILE_PATH));
export const options = config["options"];

// --- Metrics ---
const slowestPayloads = new Gauge('expb_slowest_payloads');

// --- Data ---
const payloadLines = new SharedArray('expb_payload_lines', () =>
  open(payloadsFilePath).trim().split(/\r?\n/)
);
const fcuLines = new SharedArray('expb_fcu_lines', () =>
  open(fcusFilePath).trim().split(/\r?\n/)
);

const warmupIdx0 = Math.max(0, payloadsSkip);
const startIdx0 = warmupIdx0 + Math.max(0, payloadsWarmup);
const totalPairs = Math.max(0, Math.min(payloadLines.length, fcuLines.length) - startIdx0);

// --- Helpers ---
function safeGetLine(arr, idx) {
  const v = (idx >= 0 && idx < arr.length) ? arr[idx] : '';
  return typeof v === 'string' ? v.replace(/^\uFEFF/, '').trim() : '';
}

// Tiny extractor to avoid full JSON.parse() just to tag the method
function extractMethodFast(raw) {
  const head = String(raw).slice(0, 256);
  const m = /"method"\s*:\s*"([^"]+)"/.exec(head);
  return m ? m[1] : undefined;
}

function extractJrpcIdFast(raw) {
  const head = String(raw).slice(0, 256);
  const m = /"id"\s*:\s*(\d+)/.exec(head);
  return m ? parseInt(m[1], 10) : undefined;
}

function extractGasUsedFast(raw) {
  const head = String(raw).slice(0, 256);
  const m = /"gasUsed"\s*:\s*(\d+)/.exec(head);
  return m ? parseInt(m[1], 10) : undefined;
}

function hex2ArrayBuffer(hex) {
  const buf = new ArrayBuffer(hex.length / 2);
  const view = new Uint8Array(buf);
  for (let i = 0; i < hex.length; i += 2) view[i / 2] = parseInt(hex.slice(i, i + 2), 16);
  return buf;
}
const jwtsecretBytes = hex2ArrayBuffer(open(__ENV.EXPB_JWTSECRET_FILE_PATH).trim());

// Per-VU JWT cache (refresh ~once/minute)
let jwtCache = { token: '', exp: 0 };
function getJwtToken() {
  const now = Math.floor(Date.now() / 1000);
  if (jwtCache.token && now < (jwtCache.exp - 2)) return jwtCache.token;

  const header = encoding.b64encode(JSON.stringify({ typ: 'JWT', alg: 'HS256' }), 'rawurl');
  const iat = now, exp = iat + 60;
  const payload = encoding.b64encode(JSON.stringify({ iat, exp }), 'rawurl');
  const h = crypto.createHMAC('sha256', jwtsecretBytes);
  h.update(header + '.' + payload);
  const sig = h.digest('base64rawurl');
  jwtCache = { token: `${header}.${payload}.${sig}`, exp };
  return jwtCache.token;
}

function cid() {
  return `${__ENV.testid || 'expb'}-vu${exec.vu.idInTest}-it${exec.scenario.iterationInTest}`;
}

function processPayload(idx, base_tags = {}, warmup = false) {
  // Out of data? graceful (default) or abort if explicitly requested
  if (idx >= startIdx0 + totalPairs) {
    if (ABORT_ON_EOF) exec.test.abort('No more payloads or fcus found');
    return;
  }

  const payloadRaw = safeGetLine(payloadLines, idx);
  const fcuRaw = safeGetLine(fcuLines, idx);

  if (!payloadRaw || !fcuRaw) {
    if (ABORT_ON_EOF) exec.test.abort('Dataset contains empty lines or ended prematurely');
    return;
  }

  // --- engine_newPayload ---
  const tokGP = getJwtToken();
  group('engine_newPayload', function () {
    const tags = { jrpc_method: extractMethodFast(payloadRaw) || 'engine_newPayload', kind: 'newPayload', ...base_tags };
    const headers = { Authorization: 'Bearer ' + tokGP, 'Content-Type': 'application/json' };
    if (ADD_CORRELATION_HEADER) headers['X-Expb-Cid'] = cid();

    const r = http.post(engineEndpoint, payloadRaw, { headers, tags });
    check(r, { 'status_200': (x) => x.status === 200 }, tags);
    if (!warmup && PER_PAYLOAD_METRICS) {
      const perPayloadMetricsTags = {
        ...tags,
      }
      const jrpcId = extractJrpcIdFast(payloadRaw);
      if (jrpcId) {
        perPayloadMetricsTags.jrpc_id = jrpcId;
      }
      const gasUsed = extractGasUsedFast(payloadRaw);
      if (gasUsed) {
        perPayloadMetricsTags.gas_used = gasUsed;
      }
      slowestPayloads.add(
        r.timings.duration,
        perPayloadMetricsTags,
      );
    }
  });


  // --- engine_forkchoiceUpdated ---
  const tokFC = getJwtToken();
  group('engine_forkchoiceUpdated', function () {
    const tags = { jrpc_method: extractMethodFast(fcuRaw) || 'engine_forkchoiceUpdated', kind: 'forkchoiceUpdated', ...base_tags };
    const headers = { Authorization: 'Bearer ' + tokFC, 'Content-Type': 'application/json' };
    if (ADD_CORRELATION_HEADER) headers['X-Expb-Cid'] = cid();

    const r = http.post(engineEndpoint, fcuRaw, { headers, tags });
    check(r, { 'status_200': (x) => x.status === 200 }, tags);
  });
}

export function setup() {
  // execute warmup payloads
  for (let idx = warmupIdx0; idx < startIdx0; idx++) {
    processPayload(idx, {}, true);
  }
}

export default function () {
  const idx = startIdx0 + exec.scenario.iterationInTest;

  processPayload(idx, {}, false);
}
